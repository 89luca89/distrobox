#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-only
#
# This file is part of the distrobox project: https://github.com/89luca89/distrobox
#
# Copyright (C) 2021 distrobox contributors
#
# distrobox is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.
#
# distrobox is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with distrobox; if not, see <http://www.gnu.org/licenses/>.

# POSIX
# Expected env variables:
#	HOME
#	USER
#	SHELL
# Optional env variables:
#	DBX_CONTAINER_NAME

trap '[ "$?" -ne 0 ] && printf "\nAn error occurred\n"' EXIT

# Defaults
container_command="${SHELL:-"bash"}"
# Work around for shells that are not in the container's file system, nor PATH.
# For example in hosts that do not follow FHS, like NixOS or for shells in custom
# exotic paths.
container_command="$(basename "${container_command}") -l"
container_manager_additional_flags=""
container_name="${DBX_CONTAINER_NAME:-""}"
container_name_default="fedora-toolbox-35"
dryrun=0
headless=0
verbose=0
version="1.2.13"

# Print usage to stdout.
# Arguments:
#   None
# Outputs:
#   print usage with examples.
show_help() {
	cat <<EOF
distrobox version: ${version}

Usage:

	distrobox-enter --name fedora-toolbox-35 -- bash -l
	distrobox-enter my-alpine-container -- sh -l
	distrobox-enter --additional-flags "--preserve-fds" --name test -- bash -l
	distrobox-enter --additional-flags "--env MY_VAR=value" --name test -- bash -l
	MY_VAR=value distrobox-enter --additional-flags "--preserve-fds" --name test -- bash -l

Options:

	--name/-n:		name for the distrobox						default: fedora-toolbox-35
	--/-e:			end arguments execute the rest as command to execute at login	default: bash -l
	--no-tty/-T:		do not instantiate a tty
	--additional-flags/-a:	additional flags to pass to the container manager command
	--help/-h:		show this message
	--dry-run/-d:		only print the container manager command generated
	--verbose/-v:		show more verbosity
	--version/-V:		show version
EOF
}

# Parse arguments
while :; do
	case $1 in
	-h | --help)
		# Call a "show_help" function to display a synopsis, then exit.
		show_help
		exit 0
		;;
	-v | --verbose)
		shift
		verbose=1
		;;
	-T | -H | --no-tty)
		shift
		headless=1
		;;
	-V | --version)
		printf "distrobox: %s\n" "${version}"
		exit 0
		;;
	-d | --dry-run)
		shift
		dryrun=1
		;;
	-n | --name)
		if [ -n "$2" ]; then
			container_name="$2"
			shift
			shift
		fi
		;;
	-a | --additional-flags)
		if [ -n "$2" ]; then
			container_manager_additional_flags="${container_manager_additional_flags} ${2}"
			shift
			shift
		fi
		;;
	-e | --exec | --)
		shift
		container_command=$*
		break
		;;
	*) # Default case: If no more options then break out of the loop.
		# If we have a flagless option and container_name is not specified
		# then let's accept argument as container_name
		if [ -z "${container_name}" ] && [ -n "$1" ]; then
			container_name="$1"
			shift
		else
			break
		fi
		;;
	esac
done

set -o errexit
set -o nounset
# set verbosity
if [ "${verbose}" -ne 0 ]; then
	set -o xtrace
fi

# We depend on a container manager let's be sure we have it
# First we use podman, else docker
container_manager="podman"
# Be sure we have a container manager to work with.
if ! command -v "${container_manager}" >/dev/null; then
	# If no podman, try docker.
	container_manager="docker"
	if ! command -v docker >/dev/null; then
		# Error: we need at least one between docker or podman.
		printf >&2 "Missing dependency: we need a container manager.\n"
		printf >&2 "Please install one of podman or docker.\n"
		if [ "${dryrun}" -eq 0 ]; then
			exit 127
		fi
	fi
fi
# Small performance optimization, using podman socket shaves
# about half the time to access informations.
#
# Accessed file is /run/user/USER_ID/podman/podman.sock
#
# This is not necessary on docker as it is already handled
# in this way.
# shellcheck disable=SC2312
if [ -z "${container_manager#*podman*}" ] &&
	[ -S "/run/user/$(id -ru)/podman/podman.sock" ] &&
	systemctl --user status podman.socket >/dev/null; then

	container_manager="${container_manager} --remote"
fi
# add  verbose if -v is specified
if [ "${verbose}" -ne 0 ]; then
	container_manager="${container_manager} --log-level debug"
fi
# Set default container_name if no one is specified.
if [ -z "${container_name}" ]; then
	container_name="${container_name_default}"
fi

# Generate Podman or Docker command to execute.
# Arguments:
#   None
# Outputs:
#   prints the podman or docker command to enter the distrobox container
generate_command() {
	result_command="${container_manager} exec"
	result_command="${result_command}
		--user=${USER}"

	# For some usage, like use in service, or launched by non-terminal
	# eg. from desktop files, TTY can fail to instantiate, and fail to enter
	# the container.
	# To work around this, --headless let's you skip these 2 flags and make it
	# work in tty-less situations.
	if [ "${headless}" -eq 0 ]; then
		result_command="${result_command}
			--interactive
			--tty"
	fi

	# Entering container using our user and workdir.
	# Start container from working directory. Else default to home. Else do /.
	# pass distrobox-enter path, it will be used in the distrobox-export tool.
	result_command="${result_command}
		--workdir=${PWD:-${HOME:-"/"}}
		--env=DISTROBOX_ENTER_PATH=$(realpath "${0}")"

	# Loop through all the environment vars
	# and export them to the container.
	set +o xtrace
	# disable logging fot this snippet, or it will be too talkative.
	for i in $(printenv | grep '=' | grep -Ev ' |"' |
		grep -Ev '^(HOST|HOSTNAME|HOME|PATH|SHELL|USER|XDG_.*_DIRS|_)'); do
		# We filter the environment so that we do not have strange variables,
		# multiline or containing spaces.
		# We also NEED to ignore the HOME variable, as this is set at create time
		# and needs to stay that way to use custom home dirs.
		result_command="${result_command} --env=\"${i}\""
	done

	# Ensure the standard FHS program paths are in PATH environment
	standard_paths="/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin"
	container_paths="${PATH}"
	# add to the PATH only after the host's paths, and only if not already present.
	for standard_path in ${standard_paths}; do
		if [ -n "${container_paths##*:"${standard_path}"*}" ]; then
			container_paths="${container_paths}:${standard_path}"
		fi
	done
	result_command="${result_command} --env=\"PATH=${container_paths}\""

	# Ensure the standard FHS program paths are in XDG_DATA_DIRS environment
	standard_paths="/usr/local/share /usr/share"
	container_paths="${XDG_DATA_DIRS:=}"
	# add to the XDG_DATA_DIRS only after the host's paths, and only if not already present.
	for standard_path in ${standard_paths}; do
		if [ -n "${container_paths##*:"${standard_path}"*}" ]; then
			container_paths="${container_paths}:${standard_path}"
		fi
	done
	result_command="${result_command} --env=\"XDG_DATA_DIRS=${container_paths}\""

	# Ensure the standard FHS program paths are in XDG_CONFIG_DIRS environment
	standard_paths="/etc/xdg"
	container_paths="${XDG_CONFIG_DIRS:=}"
	# add to the XDG_CONFIG_DIRS only after the host's paths, and only if not already present.
	for standard_path in ${standard_paths}; do
		if [ -n "${container_paths##*:"${standard_path}"*}" ]; then
			container_paths="${container_paths}:${standard_path}"
		fi
	done
	result_command="${result_command} --env=\"XDG_CONFIG_DIRS=${container_paths}\""

	# re-enable logging if it was enabled previously.
	if [ "${verbose}" -ne 0 ]; then
		set -o xtrace
	fi

	# Add additional flags
	result_command="${result_command} ${container_manager_additional_flags}"

	# Run selected container with specified command.
	result_command="${result_command} ${container_name} ${container_command}"

	# Return generated command.
	printf "%s" "${result_command}"
}

# dry run mode, just generate the command and print it. No execution.
if [ "${dryrun}" -ne 0 ]; then
	cmd="$(generate_command)"
	cmd="$(echo "${cmd}" | tr '[:blank:]\n' ' ' | tr -s ' ')"
	printf "%s\n" "${cmd}"
	exit 0
fi

# Inspect the container we're working with.
container_status="$(${container_manager} inspect --type container \
	"${container_name}" --format '{{.State.Status}}')"
container_exists="$?"
# Does the container exists? check if inspect reported errors
if [ "${container_exists}" -gt 0 ]; then
	# If not, prompt to create it first
	printf >&2 "Cannot find container %s, does it exist?\n" "${container_name}"
	printf >&2 "\nTry running first:\n"
	printf >&2 "\tdistrobox-create <name-of-container> --image <remote>/<docker>:<tag>\n"
	exit 1
fi

# If the container is not already running, we need to start if first
if [ "${container_status}" != "running" ]; then
	# If container is not running, start it first
	# Here, we save the timestamp before launching the start command, so we can
	# be sure we're working with this very same session of logs later.
	log_timestamp="$(date +%FT%T.%N%:z)"
	${container_manager} start "${container_name}" >/dev/null

	printf >&2 "Starting container %s\n" "${container_name}"
	printf >&2 "run this command to follow along:\n"
	printf >&2 "\t%s logs -f %s\n" "${container_manager}" "${container_name}"

	# Wait for container to start successfully.
	# We will probe the container logs every 1s to check if we have either:
	# Error or container_setup_done
	#
	# In the end, print eventual Warnings that occurred.
	while :; do
		container_manager_log="$(${container_manager} logs -t \
			--since "${log_timestamp}" \
			"${container_name}" 2>/dev/null)"
		case "${container_manager_log}" in
		*"Error"*)
			printf >&2 "%s\n" "${container_manager_log}"
			exit 1
			;;
		*"container_setup_done"*)
			break
			;;
		*)
			printf >&2 "."
			sleep 1
			;;
		esac
	done
	printf >&2 "\ndone!\n"
	# Print eventual warnings in the log.
	${container_manager} logs -t \
		--since "${log_timestamp}" \
		"${container_name}" 2>/dev/null | grep "Warning" >&2 || :
fi

# Generate the exec command and run it
cmd="$(generate_command)"
# shellcheck disable=SC2086
eval ${cmd}
