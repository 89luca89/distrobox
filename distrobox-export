#!/bin/sh
# POSIX
# Expected env variables:
#	HOME
#	USER
#	DISTROBOX_ENTER_PATH

trap '[ "$?" -ne 0 ] && echo An error occurred' EXIT

# Defaults
exported_app=""
exported_delete=0
exported_service=""
extra_flags=""
verbose=0
version="distrobox_version_placeholder"

# We depend on some commands, let's be sure we have them
base_dependencies="basename grep sed find"
for dep in ${base_dependencies}; do
	if ! command -v "${dep}" >/dev/null; then
		echo "Missing dependency: ${dep}"
		exit 127
	fi
done

# Print usage to stdout.
# Arguments:
#   None
# Outputs:
#   print usage with examples.
show_help() {
	echo "USAGE:
	distrobox version: ${version}

	distrobox-export --app mpv
	distrobox-export --service syncthing

	Note you can use --app OR --service but not together.

	Arguments:
		--app/-a:		name of the application to export
		--service/-s:		name of the service to export
		--delete/-d:		delete exported application or service
		--help/-h:		show this message
		--extra-flags/-ef:		extra flags to add to the command
		--verbose/-v:			show more verbosity
		--version/-V:			show version
	"
}

# Parse arguments
while :; do
	case $1 in
	-h | --help)
		# Call a "show_help" function to display a synopsis, then exit.
		show_help
		exit 0
		;;
	-v | --verbose)
		shift
		verbose=1
		;;
	-V | --version)
		echo "distrobox: ${version}"
		exit 0
		;;
	-a | --app)
		if [ -n "$2" ]; then
			exported_app="$2"
			shift
			shift
		fi
		;;
	-s | --service)
		if [ -n "$2" ]; then
			exported_service="$2"
			shift
			shift
		fi
		;;
	-ef | --extra-flags)
		if [ -n "$2" ]; then
			extra_flags="$2"
			shift
			shift
		fi
		;;
	-d | --delete)
		exported_delete=1
		shift
		;;
	*) # Default case: If no more options then break out of the loop.
		break ;;
	esac
done
# Ensure the foundamental variables are set and not empty, we will not proceed if
# they are not all set.
if [ -z "${exported_app}" ] && [ -z "${exported_service}" ]; then
	echo "Invalid arguments, missing app or service to export"
	exit 2
fi
if [ -n "${exported_app}" ] && [ -n "${exported_service}" ]; then
	echo "Invalid arguments, choose an app OR a service to export"
	exit 2
fi

# Also check we're running inside a container and not on the host
if [ ! -f /run/.containerenv ]; then
	echo "You must run $(basename "$0") inside a container..."
	exit 2
fi

set -o errexit
set -o nounset
# set verbosity
if [ "${verbose}" -ne 0 ]; then
	set -o xtrace
fi

container_name=$(grep "name=" /run/.containerenv | cut -d'"' -f2)
# Prefix to add to an existing command to work throught the container
container_command_prefix="${DISTROBOX_ENTER_PATH:-"distrobox-enter"} --name ${container_name} -e "

# Work on a desktop app export
if [ -n "${exported_app}" ]; then
	# Ensure the app we're exporting is installed
	if ! command -v "${exported_app}" >/dev/null; then
		echo "Error: trying to export a non-installed application"
		exit 127
	fi
	# Find desktop file for the application to export
	desktop_files=$(grep -ril "${exported_app}" /usr/share/applications/*)
	icon_files=$(find /usr/share/icons -iname "*${exported_app}*")

	# copy icons in home directory
	for icon in ${icon_files}; do
		icon_home_directory="$(dirname "${icon}" | sed "s|/usr/share/|${HOME}/.local/share/|g")"

		# check if we're exporting or deleting
		if [ "${exported_delete}" -ne 0 ]; then
			# we need to remove, not export
			rm -f "${icon_home_directory}"/"$(basename "${icon}")"
		else
			# we wanto to export the application's icons
			mkdir -p "${icon_home_directory}"
			cp "${icon}" "${icon_home_directory}"
		fi
	done

	# create desktop files for the distrobox
	for desktop_file in ${desktop_files}; do
		desktop_home_file="$(basename "${desktop_file}")"

		# check if we're exporting or deleting
		if [ "${exported_delete}" -ne 0 ]; then
			rm -f "${HOME}/.local/share/applications/${desktop_home_file}"
		else
			# If a TryExec is present, we have to fake it as it will not work throught the
			# container separation
			sed "s|^Exec=|Exec=${container_command_prefix} |g" "${desktop_file}" |
				sed "s|\(%.*\)|${extra_flags} \1|g" |
				sed "s|^TryExec=.*|TryExec=true|g" \
					>"${HOME}/.local/share/applications/${desktop_home_file}"
		fi
	done
elif [ -n "${exported_service}" ]; then
	# If we're managing services, let's be sure we have systemctl
	if ! command -v systemctl >/dev/null; then
		echo "Missing dependency: systemd"
		exit 127
	fi
	# Ensure we're working with fresh data
	systemctl --user daemon-reload
	# Fetch original service file
	service_file="${HOME}/.config/systemd/user/${exported_service}.service"
	# Create temp file with random name
	temp_file="/tmp/$(
		tr -dc A-Za-z0-9 </dev/urandom | head -c 13
		echo ''
	)"
	# Replace all Exec occurrencies
	for cmd in ExecStart ExecStartPre ExecStartPost ExecReload ExecStop ExecStopPost; do
		# Save to temp file
		systemctl --user cat "${exported_service}.service" >"${temp_file}" 2>/dev/null
		# Add prefix only if not present
		if ! grep "${cmd}" "${temp_file}" | grep -q "${container_command_prefix}"; then
			tail -n+2 "${temp_file}" |
				sed "s|^${cmd}=|${cmd}=${container_command_prefix} |g" |
				sed "s|^${cmd}=.*|& ${extra_flags}|g" >"${service_file}"
		fi
	done
	# Cleanup
	rm -f "${temp_file}"
	# Reload
	systemctl --user daemon-reload
fi
