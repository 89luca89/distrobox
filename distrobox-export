#!/bin/sh
# POSIX
# Expected env variables:
#	HOME
#	USER
#	DISTROBOX_ENTER_PATH

trap '[ "$?" -ne 0 ] && printf "An error occurred\n"' EXIT

# Defaults
exported_app=""
exported_bin=""
exported_delete=0
exported_service=""
extra_flags=""
verbose=0
version="distrobox_version_placeholder"

# We depend on some commands, let's be sure we have them
base_dependencies="basename grep sed find"
for dep in ${base_dependencies}; do
	if ! command -v "${dep}" >/dev/null; then
		printf >&2 "Missing dependency: %s\n" "${dep}"
		exit 127
	fi
done

# Print usage to stdout.
# Arguments:
#   None
# Outputs:
#   print usage with examples.
show_help() {
	cat <<EOF
distrobox version: ${version}

distrobox-export takes care of exporting an app a binary or a service from the container
to the host.

Exported app will be easily available in your normal launcher and it will
automatically be launched from the container it is exported from.

Exported services will be available in the host's user's systemd session, so

	systemctl --user status exported_service_name

will show the status of the service exported.

Exported binaries will be exported in the "--export-path" of choice as a wrapper
script that acts naturally both on the host and in the container.

You can specify additional flags to add to the command, for example if you want
to export an electron app, you could add the "--foreground" flag to the command:

	distrobox-export --app atom --extra-flags "--foreground"
	distrobox-export --bin /usr/bin/vim --export-path ~/.local/bin --extra-flags "-p"
	distrobox-export --service syncthing --extra-flags "-allow-newer-config"

This works for services, binaries and apps.
Extra flags are only used then the exported app, binary or service is used from
the host, using them inside the container will not include them.

The option "--delete" will un-export an app, binary or service.

	distrobox-export --app atom --delete
	distrobox-export --bin /usr/bin/vim --export-path ~/.local/bin --delete
	distrobox-export --service syncthing --delete

Note you can use --app OR --bin OR --service but not together.


Usage:
	distrobox-export --app mpv [--extra-flags "flags"] [--delete]
	distrobox-export --service syncthing [--extra-flags "flags"] [--delete]
	distrobox-export --bin /path/to/bin --export-path ~/.local/bin [--extra-flags "flags"] [--delete]


Options:
	--app/-a:		name of the application to export
	--bin/-b:		absolute path of the binary to export
	--service/-s:		name of the service to export
	--delete/-d:		delete exported application or service
	--export-path/-ep:	path where to export the binary
	--extra-flags/-ef:		extra flags to add to the command
	--help/-h:		show this message
	--verbose/-v:			show more verbosity
	--version/-V:			show version
EOF
}

# Print generated script from template
# Arguments:
#	distrobox name
#	binary path
# Outputs:
#   print generated script.
generate_script() {
	distrobox_name=$1
	binary_path=$2
	cat <<EOF
#!/bin/sh
# distrobox_binary
# name: ${distrobox_name}
if [ ! -f /run/.containerenv ]; then
    distrobox-enter --name ${distrobox_name} -e ${binary_path} ${extra_flags} \$@
else
    ${binary_path} \$@
fi
EOF
}

# Parse arguments
while :; do
	case $1 in
	-h | --help)
		# Call a "show_help" function to display a synopsis, then exit.
		show_help
		exit 0
		;;
	-v | --verbose)
		shift
		verbose=1
		;;
	-V | --version)
		printf "distrobox: %s\n" "${version}"
		exit 0
		;;
	-a | --app)
		if [ -n "$2" ]; then
			exported_app="$2"
			shift
			shift
		fi
		;;
	-b | --bin)
		if [ -n "$2" ]; then
			exported_bin="$2"
			shift
			shift
		fi
		;;
	-s | --service)
		if [ -n "$2" ]; then
			exported_service="$2"
			shift
			shift
		fi
		;;
	-ep | --export-path)
		if [ -n "$2" ]; then
			dest_path="$2"
			shift
			shift
		fi
		;;
	-ef | --extra-flags)
		if [ -n "$2" ]; then
			extra_flags="$2"
			shift
			shift
		fi
		;;
	-d | --delete)
		exported_delete=1
		shift
		;;
	*) # Default case: If no more options then break out of the loop.
		break ;;
	esac
done
# Ensure the foundamental variables are set and not empty, we will not proceed if
# they are not all set.
if [ -z "${exported_app}" ] &&
	[ -z "${exported_bin}" ] &&
	[ -z "${exported_service}" ]; then
	printf >&2 "Invalid arguments, choose an action below\n"
	show_help
	exit 2
fi
if [ -n "${exported_app}" ] &&
	[ -n "${exported_bin}" ] &&
	[ -n "${exported_service}" ]; then
	printf >&2 "Invalid arguments, choose only one action below\n"
	show_help
	exit 2
fi
if [ -n "${exported_bin}" ] && [ -z "${dest_path}" ]; then
	printf >&2 "Missing argument export-path\n"
	exit 2
fi

# Also check we're running inside a container and not on the host
if [ ! -f /run/.containerenv ]; then
	printf >&2 "You must run %s inside a container...\n" " $(basename "$0")"
	exit 126
fi

set -o errexit
set -o nounset
# set verbosity
if [ "${verbose}" -ne 0 ]; then
	set -o xtrace
fi

container_name=$(grep "name=" /run/.containerenv | cut -d'"' -f2)
# Prefix to add to an existing command to work throught the container
container_command_prefix="${DISTROBOX_ENTER_PATH:-"distrobox-enter"} --name ${container_name} -e "

if [ -n "${exported_bin}" ]; then
	# Work on a binary export

	# Ensure the binary we're exporting is installed
	if [ ! -f "${exported_bin}" ]; then
		printf >&2 "Error: cannot find %s\n" "${exported_bin}"
		exit 127
	fi
	# generate dest_file path
	dest_file="${dest_path}/$(basename "${exported_bin}")"

	# If we're deleting it, just do it and exit
	if [ "${exported_delete}" -ne 0 ] && grep -q "distrobox_binary" "${dest_file}"; then
		rm -f "${dest_file}"
		exit 0
	fi

	# test if we have writing rights on the file
	if ! touch "${dest_file}"; then
		printf >&2 "Error: cannot create destination file %s\n" "${dest_file}"
		exit 1
	fi

	# create the script from template and write to file
	generate_script "${container_name}" "${exported_bin}" >"${dest_file}"
	chmod +x "${dest_file}"

	exit 0

elif [ -n "${exported_app}" ]; then
	# Work on a desktop app export

	# Ensure the app we're exporting is installed
	if ! command -v "${exported_app}" >/dev/null; then
		printf >&2 "Error: trying to export a non-installed application\n"
		exit 127
	fi
	# Find desktop file for the application to export
	desktop_files=$(grep -ril "${exported_app}" /usr/share/applications/*)
	icon_files=$(find /usr/share/icons -iname "*${exported_app}*")

	# copy icons in home directory
	for icon_file in ${icon_files}; do
		icon_home_directory="$(dirname "${icon_file}" | sed "s|/usr/share/|${HOME}/.local/share/|g")"

		# check if we're exporting or deleting
		if [ "${exported_delete}" -ne 0 ]; then
			# we need to remove, not export
			rm -f "${icon_home_directory}"/"$(basename "${icon_file}")"
		else
			# we wanto to export the application's icons
			mkdir -p "${icon_home_directory}"
			cp "${icon_file}" "${icon_home_directory}"
		fi
	done

	# create desktop files for the distrobox
	for desktop_file in ${desktop_files}; do
		desktop_home_file="$(basename "${desktop_file}")"

		# check if we're exporting or deleting
		if [ "${exported_delete}" -ne 0 ]; then
			rm -f "${HOME}/.local/share/applications/${desktop_home_file}"
		else
			# If a TryExec is present, we have to fake it as it will not work throught the
			# container separation
			sed "s|^Exec=|Exec=${container_command_prefix} |g" "${desktop_file}" |
				sed "s|\(%.*\)|${extra_flags} \1|g" |
				sed "s|^TryExec=.*|TryExec=true|g" \
					>"${HOME}/.local/share/applications/${desktop_home_file}"
		fi
	done

	exit 0

elif [ -n "${exported_service}" ]; then
	# Work on a service export

	# If we're managing services, let's be sure we have systemctl
	if ! command -v systemctl >/dev/null; then
		printf >&2 "Missing dependency: systemd\n"
		exit 127
	fi
	# Ensure we're working with fresh data
	systemctl --user daemon-reload
	# Fetch original service file
	service_file="${HOME}/.config/systemd/user/${exported_service}.service"

	# If we're deleting it, just do it and exit
	if [ "${exported_delete}" -ne 0 ]; then
		rm -f "${HOME}/.config/systemd/user/${exported_service}.service"
		systemctl --user daemon-reload
		exit 0
	fi

	# Create temp file with random name
	temp_file="/tmp/$(
		tr -dc A-Za-z0-9 </dev/urandom | head -c 13
		printf "\n"
	)"
	# Replace all Exec occurrencies
	for exec_cmd in ExecStart ExecStartPre ExecStartPost ExecReload ExecStop ExecStopPost; do
		# Save to temp file
		systemctl --user cat "${exported_service}.service" >"${temp_file}" 2>/dev/null
		# Add prefix only if not present
		if ! grep "${exec_cmd}" "${temp_file}" | grep -q "${container_command_prefix}"; then
			tail -n+2 "${temp_file}" |
				sed "s|^${exec_cmd}=|${exec_cmd}=${container_command_prefix} |g" |
				sed "s|^${exec_cmd}=.*|& ${extra_flags}|g" >"${service_file}"
		fi
	done
	# Cleanup
	rm -f "${temp_file}"
	# Reload
	systemctl --user daemon-reload

	exit 0
fi
