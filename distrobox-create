#!/bin/sh
# POSIX
# Expected env variables:
#	HOME
#	USER

trap '[ "$?" -ne 0 ] && echo An error occurred' EXIT

# We depend on podman let's be sure we have it
if ! command -v podman >/dev/null; then
	echo "Missing dependency: podman"
	exit 127
fi

# Defaults
container_image="registry.fedoraproject.org/fedora-toolbox:35"
container_name="fedora-toolbox-35"
container_user_gid="$(id -rg)"
container_user_home="${HOME}"
container_user_name="${USER}"
container_user_uid="$(id -ru)"
distrobox_entrypoint_path="$(command -v distrobox-init)"
distrobox_export_path="$(command -v distrobox-export)"
verbose=0
version="distrobox_version_placeholder"

# Print usage to stdout.
# Arguments:
#   None
# Outputs:
#   print usage with examples.
show_help() {
	echo "USAGE:
	distrobox version: ${version}

	distrobox-create --image registry.fedoraproject.org/fedora-toolbox:35 --name fedora-toolbox-35

	Arguments:
		--image/-i: image to use for the container	default: registry.fedoraproject.org/fedora-toolbox:35
		--name/-n:  name for the distrobox			default: fedora-toolbox-35
		--help/-h:	show this message
		--verbose/-v:			show more verbosity
		--version/-V:			show version
	"
}

# Parse arguments
while :; do
	case $1 in
	-h | --help)
		# Call a "show_help" function to display a synopsis, then exit.
		show_help
		exit
		;;
	-v | --verbose)
		verbose=1
		shift
		;;
	-V | --version)
		echo "distrobox: ${version}"
		exit
		;;
	-i | --image)
		if [ -n "$2" ]; then
			container_image="$2"
			shift
			shift
		fi
		;;
	-n | --name)
		if [ -n "$2" ]; then
			container_name="$2"
			shift
			shift
		fi
		;;
	--) # End of all options.
		shift
		break
		;;
	*) # Default case: If no more options then break out of the loop.
		break ;;
	esac
done

set -o errexit
set -o nounset
# set verbosity
if [ "${verbose}" -ne 0 ]; then
	set -o xtrace
fi

# Generate Podman command to execute.
# Arguments:
#   None
# Outputs:
#   prints the podman command to create the distrobox container
generate_command() {

	host_directories="/ /etc /media /mnt /run /tmp /usr /var"
	host_links="/etc/host.conf /etc/hosts /etc/resolv.conf /etc/localtime /etc/timezone"

	# Set the container hostname the same as the container name.
	# use the host's namespace for ipc, network, pid, ulimit
	echo "podman create"
	if [ "${verbose}" -ne 0 ]; then
		echo "--log-level debug"
	fi
	echo "--dns none
	--env=\"XDG_RUNTIME_DIR=/run/user/${container_user_uid}\"
	--hostname ${container_name}
	--ipc host"
	# mount useful stuff inside the container.
	# we also mount host's root filesystem to /run/host, to be
	# able to syphon dynamic configurations from the host
	#
	# also mount the distrobox-init utility as the container entrypoint
	echo "--name ${container_name}
	--env=\"SHELL=${SHELL}\"
	--network host
	--no-hosts
	--pid host
	--privileged
	--security-opt label=disable
	--ulimit host
	--user root:root
	--userns keep-id
	--volume ${distrobox_entrypoint_path}:/usr/bin/entrypoint:ro"

	# let's check if we can include distrobox-export or not
	if [ -n "${distrobox_export_path}" ]; then
		echo "--volume ${distrobox_export_path}:/usr/bin/distrobox-export:ro"
	fi

	echo "--volume ${container_user_home}:${container_user_home}:rslave
	--volume /dev:/dev:rslave"

	# useful mounts from host to the container using /run/host as a base
	for host_directory in ${host_directories}; do
		# Check if the directory exists first
		if [ -d "${host_directory}" ]; then
			echo "--volume ${host_directory}:/run/host${host_directory}:rslave"
		fi
	done
	# those are dynamic configs needed by the container to function properly
	# and integrate with the host
	for link in ${host_links}; do
		# Check if the file exists first
		if [ -f "${link}" ]; then
			# Use realpath to not have multi symlink mess
			echo "--volume $(realpath "${link}"):${link}:ro"
		fi
	done

	if [ -d /run/media ]; then
		echo "--volume /run/media:/run/media:rslave"
	fi

	# mount also the XDG_RUNTIME_DIR to ensure functionality of the apps
	if [ -d /run/user/"${container_user_uid}" ]; then
		echo "--volume /run/user/${container_user_uid}:/run/user/${container_user_uid}"
	fi
	# mount devpts
	if [ -f /dev/pts ]; then
		echo "--mount type=devpts,destination=/dev/pts"
	fi

	# find all the user's socket and mount them inside the container
	# this will allow for continuity of functionality between host and container
	# for example using `podman --remote` to control the host's podman from inside
	# the container
	host_sockets="$(find /run -iname "*socket" ! -path "/run/user/*" 2>/dev/null || true)"
	for socket in ${host_sockets}; do
		echo "--volume ${socket}:${socket}"
	done

	# now execute the entrypoint, refer to `distrobox-init -h` for instructions
	echo "${container_image}
	/usr/bin/entrypoint -v --name ${container_user_name}
	--user ${container_user_uid} --group ${container_user_gid}
	--home ${container_user_home}"
}

# check that we have a complete distrobox installation or
# entrypoint and export will not work.
[ -z "${distrobox_entrypoint_path}" ] && echo "Error: no distrobox-init found in ${PATH}" && exit 1

# First, check if the image exists in the host
if ! podman image exists "${container_image}"; then
	echo >&2 "Image not found."
	echo >&2 "Do you want to pull the image now?[y/n]"
	read -r yn
	case "${yn}" in
	y | Y | yes)
		podman pull "${container_image}"
		;;
	n | N | no)
		echo >&2 "next time, run this command first:"
		echo >&2 "  podman pull ${container_image}"
		exit 1
		;;
	*) # Default case: If no more options then break out of the loop.
		echo >&2 "The available choices are: y,Y,yes,n,N,no. Exiting." ;;
	esac
fi

# Generate the command and execute
# shellcheck disable=SC2046
eval $(generate_command)
