#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-only
#
# This file is part of the distrobox project:
#    https://github.com/89luca89/distrobox
#
# Copyright (C) 2021 distrobox contributors
#
# distrobox is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.
#
# distrobox is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with distrobox; if not, see <http://www.gnu.org/licenses/>.

# Generate Podman or Docker command to execute.
# Arguments:
#   container_manager
#   container_manager_additional_flags
#   container_name
#   container_home
#   container_command
#   distrobox_enter_path
#   headless
#   skip_workdir
#   verbose
# Outputs:
#   prints the podman or docker command to enter the distrobox container
generate_enter_command() {
	# We need exactly 9 arguments
	if [ "$#" -ne 9 ]; then
		printf >&2 "Error: insufficient parameters.\n"
		return 1
	fi
	container_manager="${1}"
	container_manager_additional_flags="${2}"
	container_name="${3}"
	container_home="${4}"
	container_command="${5}"
	distrobox_enter_path="${6}"
	headless="${7}"
	skip_workdir="${8}"
	verbose="${9}"

	result_command="${container_manager} exec"
	result_command="${result_command}
		--interactive
		--user=\"${USER}\""

	# For some usage, like use in service, or launched by non-terminal
	# eg. from desktop files, TTY can fail to instantiate, and fail to enter
	# the container.
	# To work around this, --headless let's you skip the --tty flag and make it
	# work in tty-less situations.
	# Disable tty also if we're NOT in a tty (test -t 0).
	if [ "${headless}" -eq 0 ] && [ -t 0 ]; then
		result_command="${result_command}
			--tty"
	fi

	# Entering container using our user and workdir.
	# Start container from working directory. Else default to home. Else do /.
	# Since we are entering from host, drop at workdir through '/run/host'
	# which represents host's root inside container. Any directory on host
	# even if not explicitly mounted is bound to exist under /run/host.
	# Since user $HOME is very likely present in container, enter there directly
	# to avoid confusing the user about shifted paths.
	# pass distrobox-enter path, it will be used in the distrobox-export tool.
	if [ "${skip_workdir}" -eq 0 ]; then
		workdir="$(echo "${PWD:-${container_home:-"/"}}" | sed -e 's/"/\\\"/g')"
		if [ -n "${workdir##*"${container_home}"*}" ]; then
			workdir="/run/host${workdir}"
		fi
	else
		# Skipping workdir we just enter $HOME of the container.
		workdir="${container_home}"
	fi
	result_command="${result_command}
		--workdir=\"${workdir}\"
		--env \"DISTROBOX_ENTER_PATH=${distrobox_enter_path}\""
	# Loop through all the environment vars
	# and export them to the container.
	set +o xtrace
	# disable logging fot this snippet, or it will be too talkative.
	for i in $(printenv | grep '=' | grep -Ev ' |"|`|\$' |
		grep -Ev '^(HOST|HOSTNAME|HOME|PATH|SHELL|XDG_.*_DIRS|^_)'); do
		# We filter the environment so that we do not have strange variables,
		# multiline or containing spaces.
		# We also NEED to ignore the HOME variable, as this is set at create time
		# and needs to stay that way to use custom home dirs.
		result_command="${result_command} --env \"${i}\""
	done

	# Start with the $PATH set in the container's config
	container_paths="${container_path:-""}"
	# Ensure the standard FHS program paths are in PATH environment
	standard_paths="/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin"
	# add to the PATH after the existing paths, and only if not already present
	for standard_path in ${standard_paths}; do
		if [ -n "${container_paths##*:"${standard_path}"*}" ]; then
			container_paths="${container_paths}:${standard_path}"
		fi
	done
	# Ensure the $PATH entries from the host are appended as well
	for standard_path in $(echo "${PATH}" | tr ':' ' '); do
		if [ -n "${container_paths##*:"${standard_path}"*}" ]; then
			container_paths="${container_paths}:${standard_path}"
		fi
	done
	result_command="${result_command} --env \"PATH=${container_paths}\""

	# Ensure the standard FHS program paths are in XDG_DATA_DIRS environment
	standard_paths="/usr/local/share /usr/share"
	container_paths="${XDG_DATA_DIRS:=}"
	# add to the XDG_DATA_DIRS only after the host's paths, and only if not already present.
	for standard_path in ${standard_paths}; do
		if [ -n "${container_paths##*:"${standard_path}"*}" ]; then
			container_paths="${container_paths}:${standard_path}"
		fi
	done
	result_command="${result_command} --env \"XDG_DATA_DIRS=${container_paths}\""

	# Ensure the standard FHS program paths are in XDG_CONFIG_DIRS environment
	standard_paths="/etc/xdg"
	container_paths="${XDG_CONFIG_DIRS:=}"
	# add to the XDG_CONFIG_DIRS only after the host's paths, and only if not already present.
	for standard_path in ${standard_paths}; do
		if [ -n "${container_paths##*:"${standard_path}"*}" ]; then
			container_paths="${container_paths}:${standard_path}"
		fi
	done
	result_command="${result_command} --env \"XDG_CONFIG_DIRS=${container_paths}\""

	# re-enable logging if it was enabled previously.
	if [ "${verbose}" -ne 0 ]; then
		set -o xtrace
	fi

	# Add additional flags
	result_command="${result_command} ${container_manager_additional_flags}"

	# Run selected container with specified command.
	result_command="${result_command} ${container_name}"

	if [ -n "${container_command}" ]; then
		result_command="${result_command} ${container_command}"
	else
		# if no command was specified, let's execute a command that will find
		# and run the default shell for the user
		result_command="${result_command} sh -c \"\\\$(getent passwd ${USER} | cut -f 7 -d :) -l"\"
	fi

	# Return generated command.
	printf "%s" "${result_command}"
}
